// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"yqhp/gulu/internal/model"
)

func newTConfig(db *gorm.DB, opts ...gen.DOOption) tConfig {
	_tConfig := tConfig{}

	_tConfig.tConfigDo.UseDB(db, opts...)
	_tConfig.tConfigDo.UseModel(&model.TConfig{})

	tableName := _tConfig.tConfigDo.TableName()
	_tConfig.ALL = field.NewAsterisk(tableName)
	_tConfig.ID = field.NewInt64(tableName, "id")
	_tConfig.CreatedAt = field.NewTime(tableName, "created_at")
	_tConfig.UpdatedAt = field.NewTime(tableName, "updated_at")
	_tConfig.ProjectID = field.NewInt64(tableName, "project_id")
	_tConfig.EnvID = field.NewInt64(tableName, "env_id")
	_tConfig.Type = field.NewString(tableName, "type")
	_tConfig.Code = field.NewString(tableName, "code")
	_tConfig.Value = field.NewString(tableName, "value")

	_tConfig.fillFieldMap()

	return _tConfig
}

// tConfig 配置表
type tConfig struct {
	tConfigDo tConfigDo

	ALL       field.Asterisk
	ID        field.Int64
	CreatedAt field.Time
	UpdatedAt field.Time
	ProjectID field.Int64  // 项目ID(冗余)
	EnvID     field.Int64  // 环境ID
	Type      field.String // 配置类型(冗余，方便查询)
	Code      field.String // 关联配置定义的code
	Value     field.String // 配置值

	fieldMap map[string]field.Expr
}

func (t tConfig) Table(newTableName string) *tConfig {
	t.tConfigDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tConfig) As(alias string) *tConfig {
	t.tConfigDo.DO = *(t.tConfigDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tConfig) updateTableName(table string) *tConfig {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.ProjectID = field.NewInt64(table, "project_id")
	t.EnvID = field.NewInt64(table, "env_id")
	t.Type = field.NewString(table, "type")
	t.Code = field.NewString(table, "code")
	t.Value = field.NewString(table, "value")

	t.fillFieldMap()

	return t
}

func (t *tConfig) WithContext(ctx context.Context) ITConfigDo { return t.tConfigDo.WithContext(ctx) }

func (t tConfig) TableName() string { return t.tConfigDo.TableName() }

func (t tConfig) Alias() string { return t.tConfigDo.Alias() }

func (t tConfig) Columns(cols ...field.Expr) gen.Columns { return t.tConfigDo.Columns(cols...) }

func (t *tConfig) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tConfig) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 8)
	t.fieldMap["id"] = t.ID
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["project_id"] = t.ProjectID
	t.fieldMap["env_id"] = t.EnvID
	t.fieldMap["type"] = t.Type
	t.fieldMap["code"] = t.Code
	t.fieldMap["value"] = t.Value
}

func (t tConfig) clone(db *gorm.DB) tConfig {
	t.tConfigDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tConfig) replaceDB(db *gorm.DB) tConfig {
	t.tConfigDo.ReplaceDB(db)
	return t
}

type tConfigDo struct{ gen.DO }

type ITConfigDo interface {
	gen.SubQuery
	Debug() ITConfigDo
	WithContext(ctx context.Context) ITConfigDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITConfigDo
	WriteDB() ITConfigDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITConfigDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITConfigDo
	Not(conds ...gen.Condition) ITConfigDo
	Or(conds ...gen.Condition) ITConfigDo
	Select(conds ...field.Expr) ITConfigDo
	Where(conds ...gen.Condition) ITConfigDo
	Order(conds ...field.Expr) ITConfigDo
	Distinct(cols ...field.Expr) ITConfigDo
	Omit(cols ...field.Expr) ITConfigDo
	Join(table schema.Tabler, on ...field.Expr) ITConfigDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITConfigDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITConfigDo
	Group(cols ...field.Expr) ITConfigDo
	Having(conds ...gen.Condition) ITConfigDo
	Limit(limit int) ITConfigDo
	Offset(offset int) ITConfigDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITConfigDo
	Unscoped() ITConfigDo
	Create(values ...*model.TConfig) error
	CreateInBatches(values []*model.TConfig, batchSize int) error
	Save(values ...*model.TConfig) error
	First() (*model.TConfig, error)
	Take() (*model.TConfig, error)
	Last() (*model.TConfig, error)
	Find() ([]*model.TConfig, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TConfig, err error)
	FindInBatches(result *[]*model.TConfig, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TConfig) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITConfigDo
	Assign(attrs ...field.AssignExpr) ITConfigDo
	Joins(fields ...field.RelationField) ITConfigDo
	Preload(fields ...field.RelationField) ITConfigDo
	FirstOrInit() (*model.TConfig, error)
	FirstOrCreate() (*model.TConfig, error)
	FindByPage(offset int, limit int) (result []*model.TConfig, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITConfigDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tConfigDo) Debug() ITConfigDo {
	return t.withDO(t.DO.Debug())
}

func (t tConfigDo) WithContext(ctx context.Context) ITConfigDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tConfigDo) ReadDB() ITConfigDo {
	return t.Clauses(dbresolver.Read)
}

func (t tConfigDo) WriteDB() ITConfigDo {
	return t.Clauses(dbresolver.Write)
}

func (t tConfigDo) Session(config *gorm.Session) ITConfigDo {
	return t.withDO(t.DO.Session(config))
}

func (t tConfigDo) Clauses(conds ...clause.Expression) ITConfigDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tConfigDo) Returning(value interface{}, columns ...string) ITConfigDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tConfigDo) Not(conds ...gen.Condition) ITConfigDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tConfigDo) Or(conds ...gen.Condition) ITConfigDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tConfigDo) Select(conds ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tConfigDo) Where(conds ...gen.Condition) ITConfigDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tConfigDo) Order(conds ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tConfigDo) Distinct(cols ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tConfigDo) Omit(cols ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tConfigDo) Join(table schema.Tabler, on ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tConfigDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tConfigDo) RightJoin(table schema.Tabler, on ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tConfigDo) Group(cols ...field.Expr) ITConfigDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tConfigDo) Having(conds ...gen.Condition) ITConfigDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tConfigDo) Limit(limit int) ITConfigDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tConfigDo) Offset(offset int) ITConfigDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tConfigDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITConfigDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tConfigDo) Unscoped() ITConfigDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tConfigDo) Create(values ...*model.TConfig) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tConfigDo) CreateInBatches(values []*model.TConfig, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tConfigDo) Save(values ...*model.TConfig) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tConfigDo) First() (*model.TConfig, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TConfig), nil
	}
}

func (t tConfigDo) Take() (*model.TConfig, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TConfig), nil
	}
}

func (t tConfigDo) Last() (*model.TConfig, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TConfig), nil
	}
}

func (t tConfigDo) Find() ([]*model.TConfig, error) {
	result, err := t.DO.Find()
	return result.([]*model.TConfig), err
}

func (t tConfigDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TConfig, err error) {
	buf := make([]*model.TConfig, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tConfigDo) FindInBatches(result *[]*model.TConfig, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tConfigDo) Attrs(attrs ...field.AssignExpr) ITConfigDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tConfigDo) Assign(attrs ...field.AssignExpr) ITConfigDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tConfigDo) Joins(fields ...field.RelationField) ITConfigDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tConfigDo) Preload(fields ...field.RelationField) ITConfigDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tConfigDo) FirstOrInit() (*model.TConfig, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TConfig), nil
	}
}

func (t tConfigDo) FirstOrCreate() (*model.TConfig, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TConfig), nil
	}
}

func (t tConfigDo) FindByPage(offset int, limit int) (result []*model.TConfig, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tConfigDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tConfigDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tConfigDo) Delete(models ...*model.TConfig) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tConfigDo) withDO(do gen.Dao) *tConfigDo {
	t.DO = *do.(*gen.DO)
	return t
}
