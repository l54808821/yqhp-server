// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"
	"gorm.io/plugin/dbresolver"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"yqhp/gulu/internal/model"
)

func newTSkill(db *gorm.DB, opts ...gen.DOOption) tSkill {
	_tSkill := tSkill{}

	_tSkill.tSkillDo.UseDB(db, opts...)
	_tSkill.tSkillDo.UseModel(&model.TSkill{})

	tableName := _tSkill.tSkillDo.TableName()
	_tSkill.ALL = field.NewAsterisk(tableName)
	_tSkill.ID = field.NewInt64(tableName, "id")
	_tSkill.CreatedAt = field.NewTime(tableName, "created_at")
	_tSkill.UpdatedAt = field.NewTime(tableName, "updated_at")
	_tSkill.IsDelete = field.NewBool(tableName, "is_delete")
	_tSkill.CreatedBy = field.NewInt64(tableName, "created_by")
	_tSkill.Name = field.NewString(tableName, "name")
	_tSkill.Slug = field.NewString(tableName, "slug")
	_tSkill.Description = field.NewString(tableName, "description")
	_tSkill.Icon = field.NewString(tableName, "icon")
	_tSkill.Category = field.NewString(tableName, "category")
	_tSkill.Tags = field.NewString(tableName, "tags")
	_tSkill.SystemPrompt = field.NewString(tableName, "system_prompt")
	_tSkill.Variables = field.NewString(tableName, "variables")
	_tSkill.RecommendedModelParams = field.NewString(tableName, "recommended_model_params")
	_tSkill.RecommendedTools = field.NewString(tableName, "recommended_tools")
	_tSkill.RecommendedMcpServerIDs = field.NewString(tableName, "recommended_mcp_server_ids")
	_tSkill.License = field.NewString(tableName, "license")
	_tSkill.Compatibility = field.NewString(tableName, "compatibility")
	_tSkill.MetadataJSON = field.NewString(tableName, "metadata_json")
	_tSkill.AllowedTools = field.NewString(tableName, "allowed_tools")
	_tSkill.Type = field.NewInt32(tableName, "type")
	_tSkill.IsPublic = field.NewInt32(tableName, "is_public")
	_tSkill.Version = field.NewString(tableName, "version")
	_tSkill.Sort = field.NewInt32(tableName, "sort")
	_tSkill.Status = field.NewInt32(tableName, "status")

	_tSkill.fillFieldMap()

	return _tSkill
}

// tSkill AI Skill表
type tSkill struct {
	tSkillDo tSkillDo

	ALL                     field.Asterisk
	ID                      field.Int64
	CreatedAt               field.Time
	UpdatedAt               field.Time
	IsDelete                field.Bool
	CreatedBy               field.Int64  // 创建人ID
	Name                    field.String // 显示名称
	Slug                    field.String // 标准化名称kebab-case
	Description             field.String // Skill描述
	Icon                    field.String // 图标标识
	Category                field.String // 分类
	Tags                    field.String // 标签
	SystemPrompt            field.String // 系统提示词
	Variables               field.String // 变量声明
	RecommendedModelParams  field.String // 推荐模型参数
	RecommendedTools        field.String // 推荐内置工具
	RecommendedMcpServerIDs field.String // 推荐MCP服务ID
	License                 field.String // 许可证
	Compatibility           field.String // 环境要求
	MetadataJSON            field.String // 扩展元数据
	AllowedTools            field.String // 预批准工具列表
	Type                    field.Int32  // 类型: 0-用户自建 1-系统内置 2-导入
	IsPublic                field.Int32  // 是否公开
	Version                 field.String // 版本号
	Sort                    field.Int32  // 排序
	Status                  field.Int32  // 状态: 1-启用 0-禁用

	fieldMap map[string]field.Expr
}

func (t tSkill) Table(newTableName string) *tSkill {
	t.tSkillDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tSkill) As(alias string) *tSkill {
	t.tSkillDo.DO = *(t.tSkillDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tSkill) updateTableName(table string) *tSkill {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.IsDelete = field.NewBool(table, "is_delete")
	t.CreatedBy = field.NewInt64(table, "created_by")
	t.Name = field.NewString(table, "name")
	t.Slug = field.NewString(table, "slug")
	t.Description = field.NewString(table, "description")
	t.Icon = field.NewString(table, "icon")
	t.Category = field.NewString(table, "category")
	t.Tags = field.NewString(table, "tags")
	t.SystemPrompt = field.NewString(table, "system_prompt")
	t.Variables = field.NewString(table, "variables")
	t.RecommendedModelParams = field.NewString(table, "recommended_model_params")
	t.RecommendedTools = field.NewString(table, "recommended_tools")
	t.RecommendedMcpServerIDs = field.NewString(table, "recommended_mcp_server_ids")
	t.License = field.NewString(table, "license")
	t.Compatibility = field.NewString(table, "compatibility")
	t.MetadataJSON = field.NewString(table, "metadata_json")
	t.AllowedTools = field.NewString(table, "allowed_tools")
	t.Type = field.NewInt32(table, "type")
	t.IsPublic = field.NewInt32(table, "is_public")
	t.Version = field.NewString(table, "version")
	t.Sort = field.NewInt32(table, "sort")
	t.Status = field.NewInt32(table, "status")

	t.fillFieldMap()

	return t
}

func (t *tSkill) WithContext(ctx context.Context) ITSkillDo {
	return t.tSkillDo.WithContext(ctx)
}

func (t tSkill) TableName() string { return t.tSkillDo.TableName() }

func (t tSkill) Alias() string { return t.tSkillDo.Alias() }

func (t tSkill) Columns(cols ...field.Expr) gen.Columns { return t.tSkillDo.Columns(cols...) }

func (t *tSkill) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tSkill) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 25)
	t.fieldMap["id"] = t.ID
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["is_delete"] = t.IsDelete
	t.fieldMap["created_by"] = t.CreatedBy
	t.fieldMap["name"] = t.Name
	t.fieldMap["slug"] = t.Slug
	t.fieldMap["description"] = t.Description
	t.fieldMap["icon"] = t.Icon
	t.fieldMap["category"] = t.Category
	t.fieldMap["tags"] = t.Tags
	t.fieldMap["system_prompt"] = t.SystemPrompt
	t.fieldMap["variables"] = t.Variables
	t.fieldMap["recommended_model_params"] = t.RecommendedModelParams
	t.fieldMap["recommended_tools"] = t.RecommendedTools
	t.fieldMap["recommended_mcp_server_ids"] = t.RecommendedMcpServerIDs
	t.fieldMap["license"] = t.License
	t.fieldMap["compatibility"] = t.Compatibility
	t.fieldMap["metadata_json"] = t.MetadataJSON
	t.fieldMap["allowed_tools"] = t.AllowedTools
	t.fieldMap["type"] = t.Type
	t.fieldMap["is_public"] = t.IsPublic
	t.fieldMap["version"] = t.Version
	t.fieldMap["sort"] = t.Sort
	t.fieldMap["status"] = t.Status
}

func (t tSkill) clone(db *gorm.DB) tSkill {
	t.tSkillDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tSkill) replaceDB(db *gorm.DB) tSkill {
	t.tSkillDo.ReplaceDB(db)
	return t
}

type tSkillDo struct{ gen.DO }

type ITSkillDo interface {
	gen.SubQuery
	Debug() ITSkillDo
	WithContext(ctx context.Context) ITSkillDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITSkillDo
	WriteDB() ITSkillDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITSkillDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITSkillDo
	Not(conds ...gen.Condition) ITSkillDo
	Or(conds ...gen.Condition) ITSkillDo
	Select(conds ...field.Expr) ITSkillDo
	Where(conds ...gen.Condition) ITSkillDo
	Order(conds ...field.Expr) ITSkillDo
	Distinct(cols ...field.Expr) ITSkillDo
	Omit(cols ...field.Expr) ITSkillDo
	Join(table schema.Tabler, on ...field.Expr) ITSkillDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITSkillDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITSkillDo
	Group(cols ...field.Expr) ITSkillDo
	Having(conds ...gen.Condition) ITSkillDo
	Limit(limit int) ITSkillDo
	Offset(offset int) ITSkillDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITSkillDo
	Unscoped() ITSkillDo
	Create(values ...*model.TSkill) error
	CreateInBatches(values []*model.TSkill, batchSize int) error
	Save(values ...*model.TSkill) error
	First() (*model.TSkill, error)
	Take() (*model.TSkill, error)
	Last() (*model.TSkill, error)
	Find() ([]*model.TSkill, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TSkill, err error)
	FindInBatches(result *[]*model.TSkill, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TSkill) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITSkillDo
	Assign(attrs ...field.AssignExpr) ITSkillDo
	Joins(fields ...field.RelationField) ITSkillDo
	Preload(fields ...field.RelationField) ITSkillDo
	FirstOrInit() (*model.TSkill, error)
	FirstOrCreate() (*model.TSkill, error)
	FindByPage(offset int, limit int) (result []*model.TSkill, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITSkillDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tSkillDo) Debug() ITSkillDo {
	return t.withDO(t.DO.Debug())
}

func (t tSkillDo) WithContext(ctx context.Context) ITSkillDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tSkillDo) ReadDB() ITSkillDo {
	return t.Clauses(dbresolver.Read)
}

func (t tSkillDo) WriteDB() ITSkillDo {
	return t.Clauses(dbresolver.Write)
}

func (t tSkillDo) Session(config *gorm.Session) ITSkillDo {
	return t.withDO(t.DO.Session(config))
}

func (t tSkillDo) Clauses(conds ...clause.Expression) ITSkillDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tSkillDo) Returning(value interface{}, columns ...string) ITSkillDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tSkillDo) Not(conds ...gen.Condition) ITSkillDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tSkillDo) Or(conds ...gen.Condition) ITSkillDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tSkillDo) Select(conds ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tSkillDo) Where(conds ...gen.Condition) ITSkillDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tSkillDo) Order(conds ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tSkillDo) Distinct(cols ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tSkillDo) Omit(cols ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tSkillDo) Join(table schema.Tabler, on ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tSkillDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tSkillDo) RightJoin(table schema.Tabler, on ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tSkillDo) Group(cols ...field.Expr) ITSkillDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tSkillDo) Having(conds ...gen.Condition) ITSkillDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tSkillDo) Limit(limit int) ITSkillDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tSkillDo) Offset(offset int) ITSkillDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tSkillDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITSkillDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tSkillDo) Unscoped() ITSkillDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tSkillDo) Create(values ...*model.TSkill) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tSkillDo) CreateInBatches(values []*model.TSkill, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tSkillDo) Save(values ...*model.TSkill) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tSkillDo) First() (*model.TSkill, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSkill), nil
	}
}

func (t tSkillDo) Take() (*model.TSkill, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSkill), nil
	}
}

func (t tSkillDo) Last() (*model.TSkill, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSkill), nil
	}
}

func (t tSkillDo) Find() ([]*model.TSkill, error) {
	result, err := t.DO.Find()
	return result.([]*model.TSkill), err
}

func (t tSkillDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TSkill, err error) {
	buf := make([]*model.TSkill, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tSkillDo) FindInBatches(result *[]*model.TSkill, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tSkillDo) Attrs(attrs ...field.AssignExpr) ITSkillDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tSkillDo) Assign(attrs ...field.AssignExpr) ITSkillDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tSkillDo) Joins(fields ...field.RelationField) ITSkillDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tSkillDo) Preload(fields ...field.RelationField) ITSkillDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tSkillDo) FirstOrInit() (*model.TSkill, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSkill), nil
	}
}

func (t tSkillDo) FirstOrCreate() (*model.TSkill, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSkill), nil
	}
}

func (t tSkillDo) FindByPage(offset int, limit int) (result []*model.TSkill, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tSkillDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tSkillDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tSkillDo) Delete(models ...*model.TSkill) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tSkillDo) withDO(do gen.Dao) *tSkillDo {
	t.DO = *do.(*gen.DO)
	return t
}
