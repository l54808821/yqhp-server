// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"yqhp/gulu/internal/model"
)

func newTWorkflow(db *gorm.DB, opts ...gen.DOOption) tWorkflow {
	_tWorkflow := tWorkflow{}

	_tWorkflow.tWorkflowDo.UseDB(db, opts...)
	_tWorkflow.tWorkflowDo.UseModel(&model.TWorkflow{})

	tableName := _tWorkflow.tWorkflowDo.TableName()
	_tWorkflow.ALL = field.NewAsterisk(tableName)
	_tWorkflow.ID = field.NewInt64(tableName, "id")
	_tWorkflow.CreatedAt = field.NewTime(tableName, "created_at")
	_tWorkflow.UpdatedAt = field.NewTime(tableName, "updated_at")
	_tWorkflow.IsDelete = field.NewBool(tableName, "is_delete")
	_tWorkflow.CreatedBy = field.NewInt64(tableName, "created_by")
	_tWorkflow.UpdatedBy = field.NewInt64(tableName, "updated_by")
	_tWorkflow.ProjectID = field.NewInt64(tableName, "project_id")
	_tWorkflow.Name = field.NewString(tableName, "name")
	_tWorkflow.Description = field.NewString(tableName, "description")
	_tWorkflow.Version = field.NewInt32(tableName, "version")
	_tWorkflow.Definition = field.NewString(tableName, "definition")
	_tWorkflow.Status = field.NewInt32(tableName, "status")
	_tWorkflow.WorkflowType = field.NewString(tableName, "workflow_type")

	_tWorkflow.fillFieldMap()

	return _tWorkflow
}

// tWorkflow 工作流表
type tWorkflow struct {
	tWorkflowDo tWorkflowDo

	ALL          field.Asterisk
	ID           field.Int64
	CreatedAt    field.Time
	UpdatedAt    field.Time
	IsDelete     field.Bool
	CreatedBy    field.Int64  // 创建人ID
	UpdatedBy    field.Int64  // 更新人ID
	ProjectID    field.Int64  // 所属项目ID
	Name         field.String // 工作流名称
	Description  field.String // 描述
	Version      field.Int32  // 版本号
	Definition   field.String // 工作流定义(JSON格式)
	Status       field.Int32  // 状态: 1-启用 0-禁用
	WorkflowType field.String // 工作流类型: normal, performance, data_generation

	fieldMap map[string]field.Expr
}

func (t tWorkflow) Table(newTableName string) *tWorkflow {
	t.tWorkflowDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tWorkflow) As(alias string) *tWorkflow {
	t.tWorkflowDo.DO = *(t.tWorkflowDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tWorkflow) updateTableName(table string) *tWorkflow {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.IsDelete = field.NewBool(table, "is_delete")
	t.CreatedBy = field.NewInt64(table, "created_by")
	t.UpdatedBy = field.NewInt64(table, "updated_by")
	t.ProjectID = field.NewInt64(table, "project_id")
	t.Name = field.NewString(table, "name")
	t.Description = field.NewString(table, "description")
	t.Version = field.NewInt32(table, "version")
	t.Definition = field.NewString(table, "definition")
	t.Status = field.NewInt32(table, "status")
	t.WorkflowType = field.NewString(table, "workflow_type")

	t.fillFieldMap()

	return t
}

func (t *tWorkflow) WithContext(ctx context.Context) ITWorkflowDo {
	return t.tWorkflowDo.WithContext(ctx)
}

func (t tWorkflow) TableName() string { return t.tWorkflowDo.TableName() }

func (t tWorkflow) Alias() string { return t.tWorkflowDo.Alias() }

func (t tWorkflow) Columns(cols ...field.Expr) gen.Columns { return t.tWorkflowDo.Columns(cols...) }

func (t *tWorkflow) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tWorkflow) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 13)
	t.fieldMap["id"] = t.ID
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["is_delete"] = t.IsDelete
	t.fieldMap["created_by"] = t.CreatedBy
	t.fieldMap["updated_by"] = t.UpdatedBy
	t.fieldMap["project_id"] = t.ProjectID
	t.fieldMap["name"] = t.Name
	t.fieldMap["description"] = t.Description
	t.fieldMap["version"] = t.Version
	t.fieldMap["definition"] = t.Definition
	t.fieldMap["status"] = t.Status
	t.fieldMap["workflow_type"] = t.WorkflowType
}

func (t tWorkflow) clone(db *gorm.DB) tWorkflow {
	t.tWorkflowDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tWorkflow) replaceDB(db *gorm.DB) tWorkflow {
	t.tWorkflowDo.ReplaceDB(db)
	return t
}

type tWorkflowDo struct{ gen.DO }

type ITWorkflowDo interface {
	gen.SubQuery
	Debug() ITWorkflowDo
	WithContext(ctx context.Context) ITWorkflowDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITWorkflowDo
	WriteDB() ITWorkflowDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITWorkflowDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITWorkflowDo
	Not(conds ...gen.Condition) ITWorkflowDo
	Or(conds ...gen.Condition) ITWorkflowDo
	Select(conds ...field.Expr) ITWorkflowDo
	Where(conds ...gen.Condition) ITWorkflowDo
	Order(conds ...field.Expr) ITWorkflowDo
	Distinct(cols ...field.Expr) ITWorkflowDo
	Omit(cols ...field.Expr) ITWorkflowDo
	Join(table schema.Tabler, on ...field.Expr) ITWorkflowDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITWorkflowDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITWorkflowDo
	Group(cols ...field.Expr) ITWorkflowDo
	Having(conds ...gen.Condition) ITWorkflowDo
	Limit(limit int) ITWorkflowDo
	Offset(offset int) ITWorkflowDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITWorkflowDo
	Unscoped() ITWorkflowDo
	Create(values ...*model.TWorkflow) error
	CreateInBatches(values []*model.TWorkflow, batchSize int) error
	Save(values ...*model.TWorkflow) error
	First() (*model.TWorkflow, error)
	Take() (*model.TWorkflow, error)
	Last() (*model.TWorkflow, error)
	Find() ([]*model.TWorkflow, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TWorkflow, err error)
	FindInBatches(result *[]*model.TWorkflow, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TWorkflow) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITWorkflowDo
	Assign(attrs ...field.AssignExpr) ITWorkflowDo
	Joins(fields ...field.RelationField) ITWorkflowDo
	Preload(fields ...field.RelationField) ITWorkflowDo
	FirstOrInit() (*model.TWorkflow, error)
	FirstOrCreate() (*model.TWorkflow, error)
	FindByPage(offset int, limit int) (result []*model.TWorkflow, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITWorkflowDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tWorkflowDo) Debug() ITWorkflowDo {
	return t.withDO(t.DO.Debug())
}

func (t tWorkflowDo) WithContext(ctx context.Context) ITWorkflowDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tWorkflowDo) ReadDB() ITWorkflowDo {
	return t.Clauses(dbresolver.Read)
}

func (t tWorkflowDo) WriteDB() ITWorkflowDo {
	return t.Clauses(dbresolver.Write)
}

func (t tWorkflowDo) Session(config *gorm.Session) ITWorkflowDo {
	return t.withDO(t.DO.Session(config))
}

func (t tWorkflowDo) Clauses(conds ...clause.Expression) ITWorkflowDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tWorkflowDo) Returning(value interface{}, columns ...string) ITWorkflowDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tWorkflowDo) Not(conds ...gen.Condition) ITWorkflowDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tWorkflowDo) Or(conds ...gen.Condition) ITWorkflowDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tWorkflowDo) Select(conds ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tWorkflowDo) Where(conds ...gen.Condition) ITWorkflowDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tWorkflowDo) Order(conds ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tWorkflowDo) Distinct(cols ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tWorkflowDo) Omit(cols ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tWorkflowDo) Join(table schema.Tabler, on ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tWorkflowDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tWorkflowDo) RightJoin(table schema.Tabler, on ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tWorkflowDo) Group(cols ...field.Expr) ITWorkflowDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tWorkflowDo) Having(conds ...gen.Condition) ITWorkflowDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tWorkflowDo) Limit(limit int) ITWorkflowDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tWorkflowDo) Offset(offset int) ITWorkflowDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tWorkflowDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITWorkflowDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tWorkflowDo) Unscoped() ITWorkflowDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tWorkflowDo) Create(values ...*model.TWorkflow) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tWorkflowDo) CreateInBatches(values []*model.TWorkflow, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tWorkflowDo) Save(values ...*model.TWorkflow) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tWorkflowDo) First() (*model.TWorkflow, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TWorkflow), nil
	}
}

func (t tWorkflowDo) Take() (*model.TWorkflow, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TWorkflow), nil
	}
}

func (t tWorkflowDo) Last() (*model.TWorkflow, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TWorkflow), nil
	}
}

func (t tWorkflowDo) Find() ([]*model.TWorkflow, error) {
	result, err := t.DO.Find()
	return result.([]*model.TWorkflow), err
}

func (t tWorkflowDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TWorkflow, err error) {
	buf := make([]*model.TWorkflow, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tWorkflowDo) FindInBatches(result *[]*model.TWorkflow, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tWorkflowDo) Attrs(attrs ...field.AssignExpr) ITWorkflowDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tWorkflowDo) Assign(attrs ...field.AssignExpr) ITWorkflowDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tWorkflowDo) Joins(fields ...field.RelationField) ITWorkflowDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tWorkflowDo) Preload(fields ...field.RelationField) ITWorkflowDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tWorkflowDo) FirstOrInit() (*model.TWorkflow, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TWorkflow), nil
	}
}

func (t tWorkflowDo) FirstOrCreate() (*model.TWorkflow, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TWorkflow), nil
	}
}

func (t tWorkflowDo) FindByPage(offset int, limit int) (result []*model.TWorkflow, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tWorkflowDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tWorkflowDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tWorkflowDo) Delete(models ...*model.TWorkflow) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tWorkflowDo) withDO(do gen.Dao) *tWorkflowDo {
	t.DO = *do.(*gen.DO)
	return t
}
